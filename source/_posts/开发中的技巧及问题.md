---
title: 开发中的技巧及问题
date: 2019-03-22 23:57:31
tags:
categories:
---

# 开发网站记录
<!-- more -->

#组件化开发
css不换行
```css
white-space: nowrap;
```
## 下拉菜单的方式有3种
第一种是用js改变添加css，这样导致页面的回流，和重绘问题，性能低下

第二种是用js添加class类来完成操作，相对来说不错，

第三种是最优的，就是用`:hover` 伪类来解决，不过`IE6`不支持

# 分离下拉菜单，组件化开发
这种组件化开发思想确实很不错，可以节省很多代码结构，把类似的结构提出来，弄一个公共的样式
老师将的思路很清晰
[本节代码](https://github.com/DemoorBug/lx/blob/master/组件化开发/站点导航/dropdown.html)

可复用`html`
```html
<div class="dropdown menu" data-dropdown="menu">
  <div class="dropdown-toggle link">
    我的慕陶<i class="dropdown-arrow"></i>
  </div>
  <ul class="dropdown-layer dropdown-left">
  </ul>
</div>
```
复用`css`
```css
.dropdown {
  position: relative;
}

.dropdown-toggle {
  position: relative;
  z-index: 2;
}

.dropdown-arrow {
  display: inline-block;
  vertical-align: middle;
}

.dropdown-layer {
  display: none;
  z-index: 1;
  position: absolute;
}

.dropdown-left {
  left: 0;
  right: auto;
}

.dropdown-right {
  right: 0;
  left: auto;
}
```
封装可服用`javascript`
```js
(function($) {
  'use strict'
  function dropdown(elem) {
    var $elem = $(elem)
    $elem.hover(function() {
      var $this = $(this)
      $this.addClass($this.data('dropdown')+'-active');
    }, function() {
      var $this = $(this)
      $this.removeClass($this.data('dropdown')+'-active');
    })
  }
  $.fn.extend({
    dropdown: function() {
      this.each(function() {
        dropdown(this)
      })
      return this
    }
  })
})(jQuery);

$('.dropdown').dropdown()
```

# 下拉图标问题
用图片的方式至少会增加1次http请求

第二种方式就是把图片转化为`base64`，`IE6-7`不支持,编码后比原图大，不能缓存

纯`CSS`箭头，兼容`IE6`
```CSS
arrow-down {
  width: 0;
  height: 0;
  border: 4px solid #535b62;
  border-left-color: transform;
  border-left-color: transform;
  border-bottom: none;
}
```
不过呢，`IE6` 不兼容`transform`
```css
arrow-down {
  width: 0;
  height: 0;
  border: 4px solid #535b62;
  border-right-color: transform;
  _border-right-color: #fff; /* 兼容IE6写法。_只有IE6会识别 */
  border-left-color: transform;
  _border-left-color: #fff; /* 兼容IE6写法。_只有IE6会识别 */
  border-bottom: none;
}
```

## 用字体图标的技巧
因为是字体的问题，所以会继承父级的`line-height`所以我们把字体图片的，`line-height: 1`就可以解决这个问题，还用旋转图标的样式因为是`css3`的原因，所以直接用`css3`的查找方式

```css
[class*='-active'] .dropdown-arrow {
  transform: rotate(180deg);
}
```
动画呢，我基本都是单独写，因为感觉`all`老师说不高效，不过写一个利于以后的修改
```css
.transition {
  transition: all .3s
}
```

# 隐藏和显示
[本节代码]()
`trigger()`这个jquery方法居然还可以传递事件，我服了
```js
$('.box').trigger('hide');
```
给那个元素绑定的就监听那个元素
```js
$('.box').on('hide', function(e) {
  console.log(e.type)
})
```
`is()` 这个返回true，或者false
`:hidden` 匹配隐藏元素
`:visible` 匹配显示元素
初始化(防止多次点击),老师不知道为什么还给hidden添加data，我觉得没必要，难道不监听事件就不会绑定吗？应该不是，毕竟是链式调用
```js
var anim = {
  init: function($elem) {
    if ($elem.is(':hidden')) {
      $elem.data('start', 'hide')
    } else {
      $elem.data('start', 'show')
    }
  },
  hide: function($elem) {
    if($elem.data('start') === hide) return;
    $elem.data('start', 'hide').trigger('hide');
    //...
  }
}
```
通过事件监听的方式实现回调函数
```js
var anim = {
  hide: function($elem) {
    $elem.trigger('hide'); //第一个事件
    $elem.hide();
    $elem.trigger('hidden'); //隐藏完之后传递的事件
  }
}
$('.hide').on('click', function() {
  anim.hide($('.box'))
})

$('.box').on('hide hidden',function(e) {
  if(e.type ==== 'hide') {
    //执行的第一个回调函数
  } else if(e.type === 'hidden') {
    //执行的第二个回调函数
  }
})
```
# css3 隐藏和显示

`one()` 给匹配元素绑定一次事件
`off()` 删除事件
```js
show: function($elem) {
  //多次点击无效
  if ($elem.data('start') === 'show') return;
  if ($elem.data('start') === 'shown') return;
  //触发事件show
  $elem.data('start', 'show').trigger('show')
  //开始隐藏
  $elem.show()
  //css3的动画原理呢，就是给个延迟，不然就没有动画效果了
  setTimeout(function() {
    $elem.removeClass('fadeOut')
  }, 20)
  //监听transition 完成后触发该事件，抛出事件，外面就可以监听到，从而执行回调函数
  $elem.off('transitionend').one('transitionend', function() {
    $elem.data('start', 'shown').trigger('shown')
  })
},
```
隐藏略有不同
```js
hide: function($elem) {
  if ($elem.data('start') === 'hide') return;
  if ($elem.data('start') === 'hidden') return;
  $elem.data('start', 'hide').trigger('hide')
  //因为是隐藏，所以先去掉class，执行css3动画
  $elem.addClass('fadeOut')
  //transition完成后，执行该事件，隐藏该元素
  $elem.off('transitionend').one('transitionend', function() {
    $elem.hide()
    $elem.data('start', 'hidden').trigger('hidden')
  })
}
```
# 老师还讲到了浏览器对`transitionend`各浏览器的各种写法，以及兼容
```js
(function ($) {
  //各大浏览器的兼容，firefox和chrome一样
  var transitionEndEventName = {
    transition: 'transitionend',
    MozTransition: 'transitionend',
    WebkitTransition: 'webkitTransitionEnd',
    OTransition: 'oTransitionEnd otransitionend'
  }

  var transitionEnd = '',
      isSupport = false;
  for (var name in transitionEndEventName) {
    //不存在就返回undefined
    if (document.body.style[name] !== undefined) {
      transitionEnd = transitionEndEventName[name]
      isSupport = true;
      break;
    }
  }
  //如果全局存在window.mt就直接用，不存在则创建空对象
  window.mt = window.mt || {};
  window.mt.transiton = {
    end: transitionEnd,
    isSupport: isSupport
  }
})(jQuery);

```
调用
```js
console.log(window.mt.transition.end);
console.log(window.mt.transition.isSupport);
```


# 酷，下拉呀，淡入淡出，左右动画，全部都是通用的，直接修改css即可

# js切换，封装的时候有一个技巧
```js
$elem.stop().fadeIn(function () {

})
//居然可以这么写。。。。
$elem.stop()['fadeIn'](function () {

});

```

#封装，taiquanle
`proxy()` 这东西不但可以传参，还可以修改this指向，用处多多
`extend()` 可以合并对象，还可以绑定jQuery方法
这里干货满满
```js
//默认配置
var defaults = {
  css3: true,
  js: true,
  animate: 'fade'
};

function showhide($elem, options) {
  var mode = null;
  //传进来的参数和默认的对比，合并
  options = $.extend({}, defaults, options)
  //这里的transition.isSupport 是检测浏览器是否兼容css3，和js，transitionend的各浏览器兼容写法
  if (options.css3 && transition.isSupport) {
    //如果css3为true，而且浏览器兼容，就直接使用css3动画
    mode = css3[options.animate]
  } else if (options.js) {
    //不兼容css3，或者css3为false，js为true就用js动画
    mode = js[options.animate]
  } else {
    //以上两种都不行，则执行基础隐藏显示，没有动画
    mode = slide
  }
  //初始化
  mode.init($elem)
  return {
    //返回两个方法，给外界调用
    show: $.proxy(mode.show, this, $elem),
    hide: $.proxy(mode.hide, this, $elem)
  }
};
```
因为是自制行环境，所以还要将该方法暴露出去
普通暴露
```js
window.mt = window.mt || {},
window.mt.showhide = showhide

//下面的是调用形式
var showHide = window.mt.showhide($box, {
  animate: 'slideUpDown'
})
showHide.show($box)
showHide.hide($box)
```
jQuery暴露
```js
$.fn.extend({
  showHide: function (option) {
    return this.each(function () {
      //mode 这个很巧妙，没用值就执行if里面的语句，赋值，第二次进入就没问题了，老师很爱用data，巧妙
      var $this = $(this),
          mode = $(this).data('showHide');
      if (!mode) {
        //判断参数是否为对象，因为接收参数不仅接受配置，还接收调用的方法
        $this.data('showHide', mode = showhide($this, typeof option === 'object' && option))
      }
      //传进来的参数和showhide暴露的方法对比，如果不是暴露的方法就退出，是的话就执行
      if(typeof mode[option] === 'function') {
        mode[option]();
      }
    })
  }
});
```
# 用构造函数的方式重写dropdown
为什么不这样写的原因
```js
function Dropdown() {
  this.show = function () {

  }
  this.hide =function () {

  }
}
//每次实例化，都会在堆内存中开辟空间，来存放函数本体
var dropdown = new Dropdown();
var dropdown2 = new Dropdown();
var dropdown3 = new Dropdown();
```

解决this指针的几种办法
1: `$.proxy()`
```js
this.$elem.hover($.proxy(this.show, this), $.proxy(this.hide, this))
```
2: 定义_this
```js
var _this = this
this.$elem.hover(function() {
  _this.show()
}, function () {
  _this.hide()
})

```
3: ES6 Module
```js
this.$elem.hover(() => {this.show()}, () => {this.hide()})
```

# 冒泡
是从匹配元素的DOM结构向上冒泡
```html
<!DOCTYPE html>
<html lang="zh-cn">
<head>
</head>
<body>
  <div></div>
</body>
</html>
```
